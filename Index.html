<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mochi Merge: Relax Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&display=swap');

        :root {
            --bg-color: #FFF5F5;
            --ui-text: #8E8080;
            --ui-accent: #FFD1DC;
            --glass-bg: rgba(255, 255, 255, 0.6);
            --glass-border: rgba(255, 255, 255, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at 50% 100%, #ffe6e6 0%, #fffaf0 100%);
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: var(--ui-text);
            user-select: none;
            -webkit-user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #header {
            width: 90%;
            max-width: 450px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 20px;
            pointer-events: auto;
        }

        .panel {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid var(--glass-border);
            box-shadow: 0 4px 15px rgba(255, 182, 193, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
        }

        .label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .value {
            font-size: 1.4rem;
            font-weight: 600;
            color: #7A6A6A;
        }

        #next-preview canvas {
            margin-top: 5px;
        }

        #canvas-container {
            position: relative;
            margin-top: 10px;
            width: 100%;
            max-width: 420px;
            height: 70vh; /* Altura din√¢mica */
            max-height: 700px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 0 0 24px 24px; /* Fundo arredondado como um copo */
            box-shadow: 
                inset 0 -10px 20px rgba(255, 200, 200, 0.1),
                0 10px 30px rgba(189, 169, 169, 0.1);
            border: 4px solid white;
            border-top: none;
            overflow: hidden;
            pointer-events: auto;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Bot√µes de A√ß√£o */
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            pointer-events: auto;
        }

        .btn-action {
            background: white;
            border: none;
            padding: 12px 24px;
            border-radius: 50px;
            font-family: 'Fredoka', sans-serif;
            font-size: 1rem;
            color: var(--ui-text);
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.3, 2, 0.3, 1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-action:active {
            transform: scale(0.95);
        }

        .btn-action span { font-size: 1.2rem; }

        /* Mensagens Flutuantes (Combos) */
        .floating-text {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            color: #FF9AA2;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 0px white;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* Linha de Limite */
        #limit-line {
            position: absolute;
            top: 15%;
            left: 0;
            width: 100%;
            border-top: 3px dotted rgba(255, 154, 162, 0.5);
            pointer-events: none;
            display: none;
            z-index: 5;
        }
        
        #limit-warning {
            position: absolute;
            top: -25px;
            right: 10px;
            background: #FF9AA2;
            color: white;
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Tela de Game Over */
        #game-over {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #game-over.visible { opacity: 1; pointer-events: auto; }

        h1 { color: #FFB7B2; margin-bottom: 10px; }
        
        .start-btn {
            background: linear-gradient(135deg, #FFB7B2 0%, #FFDAC1 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(255, 183, 178, 0.4);
            margin-top: 20px;
            font-family: 'Fredoka', sans-serif;
            font-weight: 600;
        }

        /* Bot√£o de √Åudio */
        #mute-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
    </style>
</head>
<body>

    <button id="mute-btn">üîä</button>

    <div id="ui-layer">
        <div id="header">
            <div class="panel">
                <span class="label">Pr√≥ximo</span>
                <div id="next-preview"></div>
            </div>
            <div class="panel">
                <span class="label">Pontos</span>
                <span class="value" id="score-val">0</span>
            </div>
        </div>

        <div id="canvas-container">
            <div id="limit-line"><div id="limit-warning">Limite</div></div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="controls">
            <button class="btn-action" onclick="shakeBoard()">
                <span>üå™Ô∏è</span> Agitar
            </button>
            <button class="btn-action" id="rainbow-btn" onclick="useRainbow()" disabled style="opacity: 0.5">
                <span>üåà</span> Especial
            </button>
        </div>
    </div>

    <div id="game-over">
        <h1>Mochi Cheio!</h1>
        <p>Pontua√ß√£o Final: <span id="final-score">0</span></p>
        <p style="font-size: 0.9rem; color: #aaa">Que relaxante...</p>
        <button class="start-btn" onclick="resetGame()">Jogar de Novo</button>
    </div>

<script>
/**
 * SISTEMA DE √ÅUDIO ORG√ÇNICO (ASMR / RELAXANTE)
 * Gera sons usando Web Audio API sem arquivos externos.
 * Focado em sons de "√°gua", "madeira" e "sinos".
 */
const AudioSys = {
    ctx: null,
    isMuted: false,

    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },

    playTone(type, pitch = 1) {
        if (this.isMuted || !this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        // Configura√ß√£o baseada no tipo de som
        if (type === 'drop') {
            // Som de gota d'√°gua / bolha (Sine wave com pitch drop r√°pido)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400 * pitch, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
            
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + 0.2);
        } 
        else if (type === 'wood') {
            // Som de "Toc" suave (Madeira) - Onda triangular filtrada
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200 * pitch, t);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, t);
            
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + 0.15);
        }
        else if (type === 'chime') {
            // Som de n√≠vel alto (Sino de vento) - Harm√¥nicos
            this.createChime(t, 523.25 * pitch); // C5
            setTimeout(() => this.createChime(this.ctx.currentTime, 659.25 * pitch), 50); // E5
        }
    },

    createChime(t, freq) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); // Decay longo
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + 2);
    }
};

document.getElementById('mute-btn').addEventListener('click', (e) => {
    AudioSys.isMuted = !AudioSys.isMuted;
    e.target.innerText = AudioSys.isMuted ? 'üîá' : 'üîä';
    if (!AudioSys.ctx) AudioSys.init();
});


/**
 * CONFIGURA√á√ÉO DO JOGO
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-val');
const gameOverEl = document.getElementById('game-over');
const nextPreviewEl = document.getElementById('next-preview');
const rainbowBtn = document.getElementById('rainbow-btn');
const limitLineEl = document.getElementById('limit-line');

// Defini√ß√£o dos Mochis (Paleta Pastel Sofisticada)
const MOCHI_TYPES = [
    { r: 20, color: '#FFDAC1', face: '‚Ä¢ ‚Ä¢', label: 'Cereja' },     // Laranja Creme
    { r: 30, color: '#FFB7B2', face: ' ï‚Ä¢·¥•‚Ä¢ î', label: 'Morango' },  // Rosa Salm√£o
    { r: 42, color: '#E2F0CB', face: '^ ‚ó° ^', label: 'Matcha' },   // Verde Ch√°
    { r: 56, color: '#B5EAD7', face: '> w <', label: 'Menta' },    // Menta
    { r: 72, color: '#C7CEEA', face: 'UwU', label: 'Mirtilo' },    // Lavanda
    { r: 90, color: '#FFFACD', face: 'O w O', label: 'Lim√£o' },    // Amarelo
    { r: 108, color: '#FF9AA2', face: '‚óï ‚Äø ‚óï', label: 'P√™ssego' }, // Rosa Vivo
    { r: 128, color: '#A0E7E5', face: '‚âß‚ó°‚â¶', label: 'C√©u' },       // Azul Claro
    { r: 150, color: '#FBE7C6', face: '‚ô• ‚ó° ‚ô•', label: 'Pudim' }    // Ouro
];

const RAINBOW_TYPE = 99; // Tipo especial

// Vari√°veis de Estado
let balls = [];
let particles = [];
let floatingTexts = [];
let score = 0;
let gameOver = false;
let nextBallType = 0;
let currentX = 0;
let canDrop = true;
let comboCount = 0;
let comboTimer = null;
let rainbowCharges = 0; // Ganha uma carga a cada 1000 pontos
let lastScoreCheckpoint = 0;

// F√≠sica
const GRAVITY = 0.6;
const FRICTION = 0.95; // Mais atrito para sensa√ß√£o de "gelatina"
const ELASTICITY = 0.4; // Pouco quique

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 5 + 3;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravidade na part√≠cula
        this.life -= 0.03;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        // Desenha estrelinhas ou cora√ß√µes simplificados
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Ball {
    constructor(x, y, typeIndex) {
        this.x = x;
        this.y = y;
        this.typeIndex = typeIndex;
        
        // Se for rainbow
        if (typeIndex === RAINBOW_TYPE) {
            this.radius = 35;
            this.color = '#FFFFFF';
            this.isRainbow = true;
        } else {
            this.radius = MOCHI_TYPES[typeIndex].r;
            this.color = MOCHI_TYPES[typeIndex].color;
            this.isRainbow = false;
        }

        this.vx = 0;
        this.vy = 0;
        this.mass = this.radius;
        this.markedForDeletion = false;
        
        // Anima√ß√£o de deforma√ß√£o (Squish)
        this.scaleX = 0; // Come√ßa pequeno (pop-in)
        this.scaleY = 0;
        this.targetScale = 1;
        this.squishTimer = 0;
    }

    update() {
        // Pop-in animation
        if (this.scaleX < this.targetScale && this.squishTimer === 0) {
            this.scaleX += 0.1;
            this.scaleY += 0.1;
        } else {
            // Recupera a forma original ap√≥s impacto (efeito gelatina)
            this.scaleX += (1 - this.scaleX) * 0.1;
            this.scaleY += (1 - this.scaleY) * 0.1;
        }

        this.vy += GRAVITY;
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        this.x += this.vx;
        this.y += this.vy;

        // Paredes
        const w = canvas.width;
        const h = canvas.height;

        if (this.x - this.radius < 0) {
            this.x = this.radius;
            this.vx *= -0.5;
            this.triggerSquish(0.8, 1.2); // Esmaga verticalmente
        }
        if (this.x + this.radius > w) {
            this.x = w - this.radius;
            this.vx *= -0.5;
            this.triggerSquish(0.8, 1.2);
        }
        if (this.y + this.radius > h) {
            this.y = h - this.radius;
            this.vy *= -ELASTICITY;
            // Som de impacto leve se a velocidade for alta
            if (Math.abs(this.vy) > 2) AudioSys.playTone('wood', 1.5 - (this.radius/100));
            this.triggerSquish(1.2, 0.8); // Esmaga horizontalmente ao bater no ch√£o
        }
    }

    triggerSquish(xFactor, yFactor) {
        // S√≥ deforma se o impacto for forte o suficiente
        if (Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1) {
            this.scaleX = xFactor;
            this.scaleY = yFactor;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleX, this.scaleY);

        if (this.isRainbow) {
            // Efeito arco-√≠ris
            const gradient = ctx.createLinearGradient(-this.radius, -this.radius, this.radius, this.radius);
            gradient.addColorStop(0, '#FF9AA2');
            gradient.addColorStop(0.5, '#FFFACD');
            gradient.addColorStop(1, '#B5EAD7');
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = this.color;
        }

        // Sombra interna suave (Pseudo-3D)
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(-this.radius*0.2, -this.radius*0.2, this.radius*0.9, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.radius*0.3, this.radius*0.3, this.radius*0.8, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.05)'; // Sombra em baixo
        ctx.fill();

        // Rosto
        this.drawFace(ctx, this.radius);

        ctx.restore();
    }

    drawFace(ctx, r) {
        ctx.fillStyle = '#7A6A6A';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if (this.isRainbow) {
            ctx.font = `bold ${r*0.8}px Arial`; // Emoji simples para arco-√≠ris
            ctx.fillText('‚òÖ', 0, r*0.1);
            return;
        }

        const face = MOCHI_TYPES[this.typeIndex].face;
        
        // Desenhando texto como rosto para simplificar e permitir emoticons fofos
        // Usando fonte arredondada
        ctx.font = `bold ${r*0.4}px "Fredoka", sans-serif`;
        ctx.fillText(face, 0, 0); // Ajuste fino de altura
    }
}

/**
 * GAME LOOP & LOGIC
 */

function init() {
    AudioSys.init();
    resize();
    window.addEventListener('resize', resize);
    
    // Inputs
    canvas.addEventListener('pointerdown', handleInputStart);
    canvas.addEventListener('pointermove', handleInputMove);
    canvas.addEventListener('pointerup', handleInputEnd);

    resetGame();
    loop();
}

function resize() {
    const container = document.getElementById('canvas-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    currentX = canvas.width / 2;
}

function resetGame() {
    balls = [];
    particles = [];
    floatingTexts = [];
    score = 0;
    rainbowCharges = 0;
    updateScore(0);
    gameOver = false;
    gameOverEl.style.display = 'none';
    document.getElementById('game-over').classList.remove('visible');
    nextBallType = 0;
    updateNextPreview();
    canDrop = true;
}

function updateScore(points) {
    score += points;
    scoreEl.innerText = score;
    
    // Checkpoint para ganhar Rainbow Mochi
    if (score - lastScoreCheckpoint >= 1000) {
        rainbowCharges++;
        lastScoreCheckpoint = Math.floor(score / 1000) * 1000;
        updateButtons();
        spawnFloatingText(canvas.width/2, 100, "Rainbow Get!", "#FFD700");
    }
}

function updateButtons() {
    if (rainbowCharges > 0) {
        rainbowBtn.disabled = false;
        rainbowBtn.style.opacity = 1;
        rainbowBtn.innerHTML = `<span>üåà</span> Especial (${rainbowCharges})`;
    } else {
        rainbowBtn.disabled = true;
        rainbowBtn.style.opacity = 0.5;
        rainbowBtn.innerHTML = `<span>üåà</span> Especial`;
    }
}

function spawnFloatingText(x, y, text, color) {
    const el = document.createElement('div');
    el.className = 'floating-text';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    document.getElementById('canvas-container').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function updateNextPreview() {
    const el = document.getElementById('next-preview');
    el.innerHTML = '';
    const pCanvas = document.createElement('canvas');
    pCanvas.width = 50;
    pCanvas.height = 50;
    const pCtx = pCanvas.getContext('2d');
    
    // Se a pr√≥xima √© especial, desenha diferente
    const type = MOCHI_TYPES[nextBallType];
    
    pCtx.beginPath();
    pCtx.arc(25, 25, 15, 0, Math.PI*2);
    pCtx.fillStyle = type.color;
    pCtx.fill();
    
    // Carinha
    pCtx.fillStyle = '#7A6A6A';
    pCtx.font = '10px Arial';
    pCtx.textAlign = 'center';
    pCtx.fillText(type.face, 25, 29);
    
    el.appendChild(pCanvas);
}

// Mec√¢nica: Agitar
function shakeBoard() {
    if (gameOver) return;
    balls.forEach(b => {
        b.vy -= Math.random() * 5 + 2; // Pulo
        b.vx += (Math.random() - 0.5) * 10; // Lado
    });
    AudioSys.playTone('wood', 0.5);
}

// Mec√¢nica: Rainbow
let isRainbowNext = false;
function useRainbow() {
    if (gameOver || rainbowCharges <= 0) return;
    rainbowCharges--;
    isRainbowNext = true;
    updateButtons();
    // Visual indicator on header could be nice
}

// Input
function handleInputStart(e) {
    if (gameOver || !canDrop) return;
    if (!AudioSys.ctx) AudioSys.init(); // Inicia √°udio no primeiro toque
    updateDropPos(e);
}
function handleInputMove(e) {
    if (gameOver) return;
    updateDropPos(e);
}
function handleInputEnd(e) {
    if (gameOver || !canDrop) return;
    spawnBall();
}

function updateDropPos(e) {
    const rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    const r = isRainbowNext ? 35 : MOCHI_TYPES[nextBallType].r;
    if (x < r) x = r;
    if (x > canvas.width - r) x = canvas.width - r;
    currentX = x;
}

function spawnBall() {
    canDrop = false;
    
    let type = nextBallType;
    if (isRainbowNext) {
        type = RAINBOW_TYPE;
        isRainbowNext = false;
    }
    
    balls.push(new Ball(currentX, 50, type));
    AudioSys.playTone('drop', 2.0); // Som agudo de spawn

    setTimeout(() => { canDrop = true; }, 500);

    // Reroll normal next
    nextBallType = Math.floor(Math.random() * 3);
    updateNextPreview();
}

/**
 * RESOLU√á√ÉO DE F√çSICA E MERGE
 */
function resolve() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i];
            const b2 = balls[j];
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const distSq = dx*dx + dy*dy;
            const minDist = b1.radius + b2.radius;
            
            if (distSq < minDist * minDist) {
                // Colis√£o detectada
                const dist = Math.sqrt(distSq);
                
                // --- L√ìGICA DE FUS√ÉO ---
                let merged = false;

                // 1. Fus√£o Normal (Mesmo Tipo)
                if (b1.typeIndex === b2.typeIndex && b1.typeIndex !== RAINBOW_TYPE && b1.typeIndex < MOCHI_TYPES.length - 1) {
                    executeMerge(b1, b2, b1.typeIndex + 1);
                    merged = true;
                }
                // 2. Fus√£o Rainbow (B1 √© Rainbow)
                else if (b1.typeIndex === RAINBOW_TYPE && b2.typeIndex !== RAINBOW_TYPE && b2.typeIndex < MOCHI_TYPES.length - 1) {
                    executeMerge(b1, b2, b2.typeIndex + 1);
                    merged = true;
                }
                // 3. Fus√£o Rainbow (B2 √© Rainbow)
                else if (b2.typeIndex === RAINBOW_TYPE && b1.typeIndex !== RAINBOW_TYPE && b1.typeIndex < MOCHI_TYPES.length - 1) {
                    executeMerge(b1, b2, b1.typeIndex + 1);
                    merged = true;
                }

                if (merged) continue;

                // --- RESOLU√á√ÉO F√çSICA (EMPURR√ÉO) ---
                const nx = dx / dist;
                const ny = dy / dist;
                const overlap = minDist - dist;
                
                // Separar suavemente
                const k = 0.5 * overlap;
                b1.x -= nx * k;
                b1.y -= ny * k;
                b2.x += nx * k;
                b2.y += ny * k;
                
                // Transfer√™ncia de for√ßa (Impulse)
                const dvx = b2.vx - b1.vx;
                const dvy = b2.vy - b1.vy;
                const p = 2 * (nx * dvx + ny * dvy) / (b1.mass + b2.mass);
                
                b1.vx += p * b2.mass * nx * 0.8; // Restitui√ß√£o < 1
                b1.vy += p * b2.mass * ny * 0.8;
                b2.vx -= p * b1.mass * nx * 0.8;
                b2.vy -= p * b1.mass * ny * 0.8;
                
                // Aciona Squish se colis√£o forte
                const impact = Math.abs(dvx) + Math.abs(dvy);
                if (impact > 1.5) {
                    b1.triggerSquish(0.9, 1.1);
                    b2.triggerSquish(0.9, 1.1);
                }
            }
        }
    }
}

function executeMerge(b1, b2, newTypeIdx) {
    if (b1.markedForDeletion || b2.markedForDeletion) return;

    b1.markedForDeletion = true;
    b2.markedForDeletion = true;

    const midX = (b1.x + b2.x) / 2;
    const midY = (b1.y + b2.y) / 2;

    const newBall = new Ball(midX, midY, newTypeIdx);
    newBall.vy = -3; // Pulo para cima (celebra√ß√£o)
    balls.push(newBall);

    // Pontos
    updateScore((newTypeIdx) * 10);
    
    // Som
    if (newTypeIdx > 4) AudioSys.playTone('chime', 1.0 + (newTypeIdx * 0.1));
    else AudioSys.playTone('drop', 1.0 - (newTypeIdx * 0.05));

    // Part√≠culas
    for(let k=0; k<10; k++) {
        particles.push(new Particle(midX, midY, MOCHI_TYPES[newTypeIdx - 1]?.color || '#FFF'));
    }

    // Combo System
    registerCombo(midX, midY);
}

function registerCombo(x, y) {
    comboCount++;
    if (comboTimer) clearTimeout(comboTimer);
    
    comboTimer = setTimeout(() => {
        comboCount = 0;
    }, 1500); // 1.5s para continuar o combo

    if (comboCount > 1) {
        const words = ["Cool", "Nice", "Sweet!", "Kawaii!", "Amazing!", "SOFTY!!"];
        const idx = Math.min(comboCount - 2, words.length - 1);
        spawnFloatingText(x, y - 40, words[idx] + " x" + comboCount, "#FF9AA2");
        updateScore(comboCount * 5); // Pontos extras
    }
}

function loop() {
    if (gameOver && !document.getElementById('game-over').classList.contains('visible')) {
        document.getElementById('game-over').style.display = 'flex';
        setTimeout(() => document.getElementById('game-over').classList.add('visible'), 10);
        document.getElementById('final-score').innerText = score;
        return;
    }
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Linha Guia
    if (canDrop) {
        ctx.beginPath();
        ctx.setLineDash([5, 10]);
        ctx.moveTo(currentX, 60);
        ctx.lineTo(currentX, canvas.height);
        ctx.strokeStyle = 'rgba(142, 128, 128, 0.3)';
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Fantasma
        ctx.globalAlpha = 0.4;
        const r = isRainbowNext ? 35 : MOCHI_TYPES[nextBallType].r;
        ctx.beginPath();
        ctx.arc(currentX, 50, r, 0, Math.PI*2);
        ctx.fillStyle = isRainbowNext ? '#fff' : MOCHI_TYPES[nextBallType].color;
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    // F√≠sica (M√∫ltiplos passos para estabilidade)
    for (let s = 0; s < 6; s++) resolve();
    balls.forEach(b => b.update());
    
    // Limpeza
    balls = balls.filter(b => !b.markedForDeletion);

    // Desenho
    balls.forEach(b => b.draw(ctx));

    // Part√≠culas
    particles.forEach((p, i) => {
        p.update();
        p.draw(ctx);
        if (p.life <= 0) particles.splice(i, 1);
    });

    // Game Over Check
    const limitY = canvas.height * 0.2; // 20% do topo
    limitLineEl.style.top = limitY + 'px';
    
    // S√≥ mostramos a linha se alguma bola estiver perigosamente perto
    const danger = balls.some(b => b.y < limitY + 100 && b.vy > -1);
    limitLineEl.style.display = danger ? 'block' : 'none';

    const overflow = balls.find(b => b.y < limitY && Math.abs(b.vy) < 0.2 && Math.abs(b.vx) < 0.2 && b.y > 60);
    
    if (overflow) {
        if (!overflow.timer) overflow.timer = 0;
        overflow.timer++;
        if (overflow.timer > 100) gameOver = true;
    } else {
        balls.forEach(b => b.timer = 0);
    }

    requestAnimationFrame(loop);
}

window.onload = init;

</script>
</body>
</html>


